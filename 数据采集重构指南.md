# 数据采集重构指南

## 1. 重构目的

当前数据采集示例文件过于臃肿，代码功能多，且未做模块化区分，代码结构乱，不利于用作示例，供给客户做二次开发。客户难以理解，举步维艰，想要自己做开发时，需要我们投入很多人力去协助。为了后续客户能够方便的阅读代码，二次开发以及快速部署，数据采集代码需要重构，客户只需做少量代码开发即可正常运行。

## 2.重构方向

### 2.1 流程控制

数据采集分为遥操作采集和自动增广采集，其中自动增广采集又包括轨迹增广和视觉增广

#### 2.1.1采集时流程：

1. 创建DataCollectionManager对象，
2. 在DataCollectionManager中添加控制器(根据需要添加合适的手臂，抓夹， 腰部，腿部控制器)，控制器的值来源于PICO设备输入
3. 添加场景管理控件
4. 添加任务控件，
5. 添加数据存储状态控制器，
6. 添加数据存储控件，
7. 调用DataCollectionManager.run，2 3 4 5 6顺序无固定要求，也可不传入控件，直接运行

DataCollectionManager.run内部流程：

run内部共两层循环，内部循环用于控制单次采集任务，每完成一次采集任务，退出内部循环，将数据递交数据存储控件保存。

外层循环用于数据采集时环境重置，进入内部循环开启新任务。

下面是内部循环逻辑：

1. 调用run_controllers获取所有控制值, 然后进行仿真控制
2. 调用数据存储状态控制器，控制器绑定PICO手柄左右侧键。由采集员控制是否开始保存数据，以及停止保存。如果停止保存，调用任务控件接口**task.is_success**判断任务是否成功
3. sleep，避免控制器频率过快

下面是外部循环逻辑：

1. 调用场景管理控件，更新场景(物品位置随机，灯光随机等)。
2. 调整任务(例如抓取任务， 需要抓取的物品需要变化)
3. 调用env.reset()重置机器人相关信息，一般在reset_model中重置机器人关节中立位
4. 进入内部循环
5. 获取内部循环返回值，根据相关返回值确定是否需要保存数据到磁盘或者上传至数据中心，保存磁盘以及上传数据中心由数据储存控件完成。根据需要，可能添加多个储存控件。用于保存本地，备份，上传云端等.

**遥操作采集和数据增广采集流程区别不大，在于控制器的内部实现不同**

### 2.2 功能划分

#### 2.2.1 设备

遥操作数据采集时主要使用的设备是pico，在增广时使用到的则是hdf5文件，这里将采集保存的数据集也视作为一种设备。控制器的数据来自于设备。如果有需要可以增加键盘，手柄设备等。

#### 2.2.2 控制器

控制器主要实现控制逻辑，机器人相关控制器输出mujoco执行器id和控制值的映射。任务状态控制器用于控制数据何时开始保存，何时停止。他们数据来源于设备

#### 2.2.3 场景管理控件

场景管理控件用于控制场景的变化，例如物品随机，物品位置随机，物品材质随机，灯光随机等。或者复原场景物品位置。

#### 2.2.4 数据存储控件

数据存储控件用于保存采集的数据，比较关键的数据有hdf5文件, MP4文件，任务元数据metadata文件。

#### 2.2.5 数据采集管理控件

数据采集管理控件用于控制整个数据采集流程。

### 2.3 API设计

#### 2.3.1 Devices API

```python
# 详细参考devices.abstract_device模块
class AbstractDevice(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def update(self):
        raise NotImplementedError

#所有的设备都应该继承AbstractDevice类，目前只实现了PICO设备的相关接口，update用于更新数据。数据设备可以参考PICO设备的实现，控制#器可以将控制逻辑绑定到数据设备上的某个数据集，当设备数据进行更新时，同步更新控制器的值。
#DataDevic类暂未实现，hdf5文件保存的数据集内部格式可能会有不同，需要提供一组抽象接口。
#抽象接口由AbstractDataDevice类提供

```

#### 2.3.2 Controller API

```python
class AbstractController(metaclass=abc.ABCMeta):
    #! 参数说明
    #! env: 环境
    #! ctrl_index: 控制器的索引，与关节索引对齐
    #! init_ctrl: 控制器的索引和初始值的对应
    #! base_body: 基座体
    def __init__(self,
                env: OrcaGymLocalEnv, 
                ctrl_index: list[int],
                init_ctrl: dict[int, float],
                base_body: str):
        self.env = env
        self.ctrl_index = ctrl_index
        self.init_ctrl = init_ctrl
        self.base_link = env.body(base_body)
  
    @abc.abstractmethod
    def run_controller(self)-> dict[int, float]:
        raise NotImplementedError("Subclasses must implement this method")3
# 所有的控制器都应该继承AbstractController类，实现run_controller函数
# 相关控制器实现可以参考controllers.controller_2f85, controllers.controller_arm
```

#### 2.3.3 Task

```python
class AbstractTask(metaclass=abc.ABCMeta):
    def __init__(self, env: OrcaGymLocalEnv):
        self.env = env

    @abc.abstractmethod
    def is_success(self):
        raise NotImplementedError("Subclasses must implement this method")

    @abc.abstractmethod
    def get_task(self, scene_manager: SceneManager):
        raise NotImplementedError("Subclasses must implement this method")
# 任务类只需实现get_task和is_success，之前的Task类混杂了很多功能，随机化的功能加在任务类不合适，
# 有关场景控制的功能都应该放到SceneManger里实现
```

#### 2.3.4 SceneManage

```python
#SceneManage负责场景控制，物品随机化，灯光随机化等，接口参考以前的接口进行修改
#实现文件查看scene_manager.py  
```

#### 2.3.5 DataStorage

```python
# DataStorage负责数据存储
# 已经定义了部分接口在abstract_data_storage.py中
# 该类需要提供数据存储接口，需要提供元数据，视频文件，hdf5文件的目录定义，文件保存功能

```
